<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="spring-batch">
  <title>C24 IO support for Spring Batch</title>
  <abstract>
    <para>Spring Batch provides an extension of the Spring programming model to enable the
      development of robust batch applications vital for the daily operations of enterprise
      systems.Â C24 IO components for Spring Batch makes C24 parsing, validation and transformation
      directly usable as Spring Batch components.</para>
  </abstract>
  <section id="intro">
    <title>Introduction</title>
    <para>C24 IO Spring Batch support extends the Spring Batch Core with implementations of
      ItemReaders &amp; ItemProcessors designed to make it easy to work with C24 IO generated types,
      transforms and data in Spring Batch jobs.</para>
    <para>This guide assumes the reader is familiar with Spring and Spring configuration; please
      review the documentation at SpringSource if not.</para>
    <para>This guide will emphasise the use of Spring XML namespaces to configure C24 IO Spring
      components although other standard Spring configuration constructs are available. In general a
      minimal namespace would look like:
      <programlisting language="xml">&lt;beans:beans xmlns="http://www.springframework.org/schema/batch" 
     xmlns:beans="http://www.springframework.org/schema/beans" 
     xmlns:c24="http://schema.c24.biz/spring-core"
     xmlns:bat-c24="http://schema.c24.biz/spring-batch"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="
     	http://schema.c24.biz/spring-core		   http://schema.c24.biz/spring-core.xsd
     	http://schema.c24.biz/spring-batch		  http://schema.c24.biz/spring-batch.xsd
         http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
         http://www.springframework.org/schema/batch http://www.springframework.org/schema/batch/spring-batch.xsd"></programlisting></para>
  </section>
  <section id="parsing">
    <title>Parsing &amp; Validation</title>
    <para>C24 Spring Batch provides an ItemReader that reads data from a source and parses the
      result into a C24 model.</para>
    <para>The first stage is to identify the model which represents the unparsed data. Using the C24
      Spring Core namespace, the model bean can be declared as:</para>
    <para>
      <programlisting><code>  &lt;c24:model id="demoModel" base-element="biz.c24.demo.model.MyElement"/></code></programlisting>
    </para>
    <para>where biz.c24.demo.model.MyElement is the top-level Element class generated by C24 IO for
      your model. </para>
    <para>Remember that the Spring Batch paradigm  effectively streams elements from the data
      source, thus the model class is the Element of the individual element and not the containing
      one; for examples if you have a file containing multiple Receipts, you may generate a Receipt
      type to model the receipt and a Receipts type (containing zero or more Receipt) to model the
      file - we would use the ReceiptElement in this case (and not the ReceiptsElement).</para>
    <para>In its current form thefore, the ItemReader is better suited for fixed length or delimited
      files (e.g.CSV) than it is for hierarchical files (e.g. XML) although the splitting capability
      (see below) may be able to take care of these concerns.</para>
    <section>
      <title>Sources</title>
      <para>The C24 ItemReader needs a source from which to read its data. Currently there are 2
        supported sources:<itemizedlist>
          <listitem>
            <para>biz.c24.io.spring.batch.reader.source.FileSource</para>
          </listitem>
          <listitem>
            <para>biz.c24.io.spring.batch.reader.source.ZipFileSource</para>
          </listitem>
        </itemizedlist>The first of these reads from a single, uncompressed file while the latter
        accepts a zip file as input and will process the contents of all contained files.</para>
      <para>Both sources derive their input filename from a JobParameter called 'input.file' (as
        populated by the Spring Batch Admin
        org.springframework.batch.admin.integration.FileToJobLaunchRequestAdapter). </para>
      <para>Constructing the source requires creating an appropriate bean, for example:</para>
      <para>
        <programlisting><code>  &lt;beans:bean id="fileSource"    class="biz.c24.io.spring.batch.reader.source.FileSource" scope="step"/>
  &lt;beans:bean id="zipFileSource"  class="biz.c24.io.spring.batch.reader.source.ZipFileSource" scope="step"/></code></programlisting>
      </para>
      <para>Note that the source is declared with a scope of step. This is because it holds data
        relevant to the current step execution, hence a separate instance is required for
        each.</para>
    </section>
    <section>
      <title>C24ItemReader</title>
      <para>The C24ItemReader can be used as a standard ItemReader in any Spring Batch flow.
        Assuming the namespace declarations above, it is instantiated as:</para>
      <para>
        <programlisting><code>  &lt;bat-c24:item-reader id="ioItemReader" model-ref="demoModel" source-ref="fileSource" elementStartPattern=".*201\d-\d\d-\d\dT.*" validate="true" scope="step"/> </code></programlisting>
      </para>
      <para>In order, these attributes are:</para>
      <para>
        <itemizedlist>
          <listitem>
            <para>id - id of the bean, used to refer to it later in the job configuration</para>
          </listitem>
          <listitem>
            <para>model-ref - the id of the model we declared earlier [Mandatory]</para>
          </listitem>
          <listitem>
            <para>source-ref - the id of the source we declared earlier [Mandatory]</para>
          </listitem>
          <listitem>
            <para>elementStartPattern - a regular expression used to speed up parsing performance
              [Optional]</para>
          </listitem>
          <listitem>
            <para>validate - whether or not to validate the parsed object [Optional - default
              false]</para>
          </listitem>
          <listitem>
            <para>scope - the bean's scope [Optional - default step]</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>If validation is selected then a ValidationManager will be used to check all parsed
        ComplexDataObjects, and a ValidationException will be thrown in the event of any validation
        failures. If all reads (and validations if enabled) are successful then the ItemReader will
        return null once there is no data left to parse (in the case of the zip file, all contained
        files will be parsed before this happens).</para>
      <para>The C24ItemReader bean defaults to a scope of 'step' to ensure that concurrent
        invocations of the same step do not conflict with eachother. This can be overriden if
        desired but is not recommended.</para>
      <para>At this time the C24ItemReader does not provide support for resuming a job (ie via
        tracking progress through its source in the StepContext) however it does support both
        task-executors (for multi-threaded processing) and chunks. Setting the chunk size
        appropriately means that the parsing, validation &amp; transformation can run with
        relatively low memory consumption even with extremely large source files.</para>
      <para>During the parsing phase, exceptions thrown by the iO generated code will be wrapped up
        as Spring Batch UnexpectedInputException or NonTransientResourceExceptions (at least, as
        best as the ItemReader can determine) and rethrown.</para>
    </section>
    <section>
      <title>Splitting</title>
      <para>For complex models, parsing can be a relatively expensive operation. The C24ItemReader
        allows multiple threads to be consuming data from it concurrently, however as by default an
        element needs to be fully parsed before the start point of the next element in the file can
        be determined, this part of the process effectively becomes single-threaded (validation will
        always be performed in parallel however).</para>
      <para>The C24ItemReader supports an optional 'elementStartPattern' regular expression to allow
        individual elements to be rapidly 'split' out of the inbound data stream so subequent
        parsing operations can take place in parallel. While the splitting is also a single-threaded
        activity it is usually much faster than a full parse and hence allows more of the process to
        happen in parallel.</para>
      <para>The elementStartPattern is used to detect the first line in a new element (e.g. in the
        example above we are looking for a line which contains a date in the 201x, e.g.
        2012-05-21T). When the ItemReader sees a matching line, it starts a new element with that
        line as its initial line. If the ItemReader was already in the process of reading an
        element, it will be returned to the calling process. Thus the splitter can be used to skip
        header rows, by ensuring that they do not match the pattern. </para>
    </section>
    <section>
      <title>Validation</title>
      <para>If enabled via the 'validate' attribute, the C24ItemReader will use a validation manager
        to validate the parsed CDO. In the event of a violation, the iO exception will be wrapped
        and rethrown as a Spring Batch ParseException.</para>
    </section>
  </section>
  <section>
    <title>Transformation</title>
    <para>iO-generated transformations can be used in Spring Batch as ItemProcessors. The
      C24TransformItemProcessor takes in a raw iO-generated transform and exposes it via a
      ItemProcessor interface:</para>
    <para>
      <programlisting>  &lt;beans:bean id="demoTransform" class="biz.c24.demo.DemoTransform"/>
  &lt;bat-c24:transform-item-processor id="ioItemProcessor" transform-ref="demoTransform" validate="true"/></programlisting>
    </para>
    <para>Or equivalently in Java:</para>
    <para>
      <programlisting>@Bean 
public C24TransformItemProcessor getIoItemProcessor() { 
  return new C24TransformItemProcessor(new DemoTransform(), true); 
}</programlisting>
    </para>
    <para>The result of the transformation will also be a ComplexDataObject, but its ComplexDataType
      will be that of the destination type.</para>
    <section>
      <title>Validation</title>
      <para>The C24TransformItemProcessor can also optionally validate the resultant
        ComplexDataObject using a validation manager. To enable this functionality, set the
        'validate' attribute on the processor to true.</para>
      <para>The processor will throw an exception if validation fails, however unlike the
        C24ItemReader it will allow the iO ValidationException to propogate directly out of the
        processor without wrapping it.</para>
    </section>
  </section>
  <section>
    <title>Writing</title>
    <para>C24 iO Components for Spring Batch provides a convenient mechanism to write a
      ComplexDataObject through a Sink to a java.io.Writer. As with the C24ItemReader, the
      C24ItemWriter also decouples the external container to allow multiple potential (types of)
      destination to be supported.</para>
    <section>
      <title>WriterSources</title>
      <para>The C24 ItemWrtier needs to know where to write the output from the Sink. Currently
        there is a single supported implementation:<itemizedlist>
          <listitem>
            <para>biz.c24.io.spring.batch.writer.source.FileWriterSource</para>
          </listitem>
        </itemizedlist></para>
      <para>The FileWriterSource writes all data to a single file, without any limits on the file
        size. It determines the file to write from a JobParameter called 'output.file'.</para>
      <para>Constructing the source requires creating an appropriate bean, for example:</para>
      <para>
        <programlisting><code>  &lt;beans:bean id="fileWriterSource"    class="biz.c24.io.spring.batch.writer.source.FileWriterSource" scope="step"/></code></programlisting>
      </para>
      <para>Note that the source is declared with a scope of step. This is because it holds data
        relevant to the current step execution, hence a separate instance is required for
        each.</para>
    </section>
    <section>
      <title>C24ItemWriter</title>
      <para>The C24ItemWriter wraps a Sink &amp; a WriterSource. It is declared as:</para>
      <para>
        <programlisting>    &lt;beans:bean id="textualSink" class="biz.c24.io.api.presentation.TextualSink"/>

    &lt;bat-c24:item-writer id="ioItemWriter" sink-ref="textualSink" writer-source-ref="fileWriterSource"/>   </programlisting>
      </para>
      <para>The available attributes are:<itemizedlist>
          <listitem>
            <para>id - The id of the C24ItemWriter (used when declaring the chunk)</para>
          </listitem>
          <listitem>
            <para>sink-ref - The id of the iO Sink to use to marshall the ComplexDataObject
              [Mandatory]</para>
          </listitem>
          <listitem>
            <para>writer-source-ref - The id of the WriterSource to use [Mandatory]</para>
          </listitem>
          <listitem>
            <para>scope - The bean scope [Optional - default Step]</para>
          </listitem>
        </itemizedlist></para>
      <para/>
      <para>The bean has a default scope of 'step' as its embedded WriterSource is likely to store
        instance-specific data; this can of course be overriden but is not recommended.</para>
      <para>Internally when write is called, the C24ItemWriter will sink all supplied
        ComplexDataObjects into an internal structure before acquiring a Writer from the
        WriterSource and writing the resultant data in a single blocking call. This means that while
        elements within a chunk will remain in the same order that the C24ItemWriter received them,
        if the writer is being exercised in parallel (e.g. the parent Tasklet has a task-executor)
        there is no guarantee that the chunks themselves will be written in order. If absolute
        ordering is imperative, the entire step must be run single-threaded.</para>
    </section>
  </section>
  <section>
    <title>Examples</title>
    <para>The following is a minimal set-up for trying out the C24 Spring Batch components. It sets
      up a basic job repository, transaction manager &amp; launcher. These are purely in-memory,
      minimum effort implementations and are unlikely to be sufficient for most practical purposes;
      please see the Spring Batch documentation for approrpriate alternatives.</para>
    <para>The code shown in this section and sample data are included in the c24-springbatch
      example, part of the C24 Spring Examples repository on GitHub:
      https://github.com/C24-Technologies/c24-spring-samples </para>
    <programlisting>&lt;beans:beans xmlns="http://www.springframework.org/schema/batch" 
     xmlns:beans="http://www.springframework.org/schema/beans" 
     xmlns:c24="http://schema.c24.biz/spring-core"
     xmlns:bat-c24="http://schema.c24.biz/spring-batch"
     xmlns:task="http://www.springframework.org/schema/task"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="
        http://schema.c24.biz/spring-core	        http://schema.c24.biz/spring-core.xsd
        http://schema.c24.biz/spring-batch		   http://schema.c24.biz/spring-batch.xsd
        http://www.springframework.org/schema/task   http://www.springframework.org/schema/task/spring-task.xsd
        http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/batch  http://www.springframework.org/schema/batch/spring-batch.xsd">
	
	&lt;!-- A no-op transaction manager -->
	&lt;beans:bean id="transactionManager" class="org.springframework.batch.support.transaction.ResourcelessTransactionManager"/>

	&lt;!-- An in-memory job repository -->
	&lt;beans:bean id="jobRepository" class="org.springframework.batch.core.repository.support.MapJobRepositoryFactoryBean"/>

	&lt;!-- A simple job launcher which kicks off tasks asynchronously -->
 	&lt;beans:bean id="jobLauncher" class="org.springframework.batch.core.launch.support.SimpleJobLauncher">
    	&lt;beans:property name="jobRepository" ref="jobRepository" />
    	    &lt;beans:property name="taskExecutor">
    	    	&lt;beans:bean class="org.springframework.core.task.SimpleAsyncTaskExecutor"/>
   	 	&lt;/beans:property>
      &lt;/beans:bean>
&lt;/beans:bean></programlisting>
    <section>
      <title>A Basic Parsing C24 IO Spring Batch Job</title>
      <para>Now that we have the basic scaffolding in place, we can declare our C24 Spring Batch
        beans. First the
        ItemReader:<programlisting>	&lt;c24:model id="employeeModel" base-element="biz.c24.io.examples.models.basic.EmployeeElement"/>
	&lt;beans:bean id="fileSource" class="biz.c24.io.spring.batch.reader.source.FileSource" scope="step"/>
    &lt;bat-c24:item-reader id="ioItemReader" model-ref="employeeModel" source-ref="fileSource" elementStartPattern=".*" validate="true"/>
	</programlisting></para>
      <para>replacing <code>biz.c24.io.examples.models.basic.EmployeeElement</code> with the fully
        qualified path to your generated model Element. The elementStartPattern shown above assumes
        that each element that we're going to read from the source file is contained on a single
        line and that there are no header or comment lines (ie every line is an element).</para>
      <para>Now we define a simple job to read (and implicitly validate) ComplexDataObjects from our
        source:</para>
      <para>
        <programlisting>    &lt;job id="fileLoader">
		&lt;step id="parseFile">
    		&lt;tasklet>
    			&lt;chunk reader="ioItemReader" writer="ioItemWriter" commit-interval="100"/>
    		&lt;/tasklet>
    	&lt;/step>
    &lt;/job></programlisting>
      </para>
      <para>This has:<itemizedlist>
          <listitem>
            <para>Created a job called fileLoader</para>
          </listitem>
          <listitem>
            <para>Added a single step called parseFile</para>
          </listitem>
          <listitem>
            <para>Read items (ComplexDataObjects) from our ioItemReader bean then once it has read
              100 items (the commit-interval) it will pass all of them to an ItemWriter in a single
              invocation. Most writers will work more efficiently if they are called with an
              appropriately sized batch of items (particularly where transactions are
              involved).</para>
          </listitem>
        </itemizedlist></para>
      <para>We'll come back to the writer attribute shortly, but normally it will be specific to
        your application as you hand off the parsed &amp; validated objects to downstream
        processing. If you're using the c24-springbatch example application you can use the supplied
        ConsoleItemWriter to write the ComplexDataObject to the console:</para>
      <para>
        <programlisting>  &lt;beans:bean id="ioItemWriter" class="biz.c24.batchdemo.writers.ConsoleWriter"/></programlisting>
      </para>
      <para>Now it's time to launch our job and see it working. Normally job triggering would be
        handled by the framework; for now we'll launch it manually:</para>
      <para>
        <programlisting>	public static void main(String[] args) throws JobExecutionAlreadyRunningException, JobRestartException, JobInstanceAlreadyCompleteException, JobParametersInvalidException, IOException {
		
		// Create our application context - assumes the Spring configuration is in the classpath in a file called spring-config.xml
		ApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml");
		
		// Get the job from our Spring context
		Job job = context.getBean("parseFile", Job.class);

		// .. and a single JobLauncher bean
		JobLauncher jobLauncher = context.getBean(JobLauncher.class);
		
		// Create the job parameters and supply the name of the file to parse
		Map&lt;String, JobParameter> params = new HashMap&lt;String, JobParameter>();

		// The C24 Spring Batch sources expect to get the filename from a job property called input.file
		// In this case, the file is in the classpath and is called employees-3-valid.csv
		params.put("input.file", new JobParameter(new ClassPathResource("employees-3-valid.csv").getFile().getAbsolutePath()));

		JobParameters jobParameters = new JobParameters(params);

		// Launch the job!
		jobLauncher.run(job, jobParameters);

	}</programlisting>
      </para>
      <para>If you're using the sample data from the c24-springbatch example you should see the
        following written to the console:</para>
      <para>
        <programlisting>Mr,Andy,Acheson,Software Developer
Mr,Joe,Bloggs,Security Guard
Mr,Greg,Gatsby,Managing Director</programlisting>
      </para>
      <para>There are numerous other potential attributes that can be set on the chunk &amp; tasklet
        (for example, can it be restarted, how many elements need to fail to parse/validate before
        the entire job should be abandoned etc); please see the Spring Batch documentation for
        further detail.</para>
    </section>
    <section>
      <title>Adding a Transform</title>
      <para>Wiring in a Transform simply requires additional configuration. The example code
        includes an EmployeeToEmailTransform which we'll use to generate an email address for each
        employee.</para>
      <para>Add the following to the Spring configuration:</para>
      <para>
        <programlisting>	<emphasis role="bold">&lt;beans:bean id="employeeToEmailTransform" class="biz.c24.io.examples.transforms.basic.EmployeeToEmailTransform"/>
	&lt;bat-c24:transform-item-processor id="transformItemProcessor" transform-ref="employeeToEmailTransform" validate="true"/></emphasis>
    
    &lt;job id="fileLoader">
		&lt;step id="parseFile">
    		&lt;tasklet>
    			&lt;chunk reader="ioItemReader" <emphasis role="bold">processor="transformItemProcessor"</emphasis> writer="ioItemWriter" commit-interval="100"/>
    		&lt;/tasklet>
    	&lt;/step>
    &lt;/job></programlisting>
      </para>
      <para>Now once read and validated, the Employeees will be transformed into Emails and the
        resulting email checked for validity before handing the resulting ComplexDataObject off to
        the ItemWriter. Re-run the code with the sample data again and you should now see:</para>
      <para>
        <programlisting>A.Acheson@company.com
J.Bloggs@company.com
G.Gatsby@company.com</programlisting>
      </para>
    </section>
    <section>
      <title>Writing Out The Result</title>
      <para>The ConsoleItemWriter we've used so far does nothing more than call
          <code>toString()</code> on the Objects that are passed to it. The C24ItemWriter supports a
        pluggable marshaller (Sink) and destination (Writer). To finish off the final stage of our
        example application, we'll use iO's TextualSink to generate a valid representation of our
        object and write the result to a file.</para>
      <para>First we need to declare the Sink &amp; a WriterSource:</para>
      <para><programlisting>  &lt;beans:bean id="textualSink" class="biz.c24.io.api.presentation.TextualSink"/>
  &lt;beans:bean id="fileWriterSource" class="biz.c24.io.spring.batch.writer.source.FileWriterSource"/></programlisting>
        The we need to declare the C24ItemWriter:</para>
      <para>
        <programlisting>  &lt;bat-c24:item-writer id="ioItemWriter" sink-ref="textualSink" writer-source-ref="fileWriterSource"/>   
</programlisting>
      </para>
      <para>Finally we update our Step's Chunk to use the new ItemWriter:</para>
      <para>
        <programlisting>    &lt;job id="fileLoader">
		&lt;step id="parseFile">
    		&lt;tasklet>
    			&lt;chunk reader="ioItemReader" processor="transformItemProcessor" writer="<emphasis role="bold">ioItemWriter</emphasis>" commit-interval="100"/>
    		&lt;/tasklet>
    	&lt;/step>
    &lt;/job></programlisting>
      </para>
      <para>Recall that the FileWriterSource expects a job parameter called output.file to tell it
        where to write to. We need to update our test job launching code to supply this
        parameter:</para>
      <para>
        <programlisting>        ...

		// The C24 Spring Batch sources expect to get the filename from a job property called input.file
		// In this case, the file is in the classpath and is called employees-3-valid.csv
		params.put("input.file", new JobParameter(new ClassPathResource("employees-3-valid.csv").getFile().getAbsolutePath()));
		
<emphasis role="bold">		File outputFile = File.createTempFile("RunJob-", ".csv");
		System.out.println("Transforming to " + outputFile.getAbsolutePath());		
		params.put("output.file", new JobParameter(outputFile.getAbsolutePath()));</emphasis>
		
		JobParameters jobParameters = new JobParameters(params);

        ...</programlisting>
      </para>
      <para>The file that the data was written to will be shown on the console, for example:</para>
      <para>
        <programlisting>Transforming to /tmp/RunJob-1050960762367529182.csv</programlisting>
      </para>
      <para>And the contents with the sample data will look like:</para>
      <para>
        <programlisting>A.Acheson@company.com
J.Bloggs@company.com
G.Gatsby@company.com</programlisting>
      </para>
    </section>
    <section>
      <title>Running in Parallel</title>
      <para>When we configured our ItemReader we specified an elementStartPattern. This means that
        as well as validating ComplexDataObjects in parallel, we can parallelise most of the
        parsing, transforming and writing too. This requires 2 steps: create a task dispatcher pool
        and tell the tasklet to use it:</para>
      <programlisting>    <emphasis role="bold">&lt;task:executor id="fileLoadingPool" pool-size="8"/></emphasis>
    
    ...

    &lt;job id="fileLoader">
		&lt;step id="parseFile">
    		&lt;tasklet <emphasis role="bold">task-executor="fileLoadingPool" throttle-limit="8"</emphasis>>
    			&lt;chunk reader="ioItemReader" processor="transformItemProcessor" writer="ioItemWriter" commit-interval="100"/>
    		&lt;/tasklet>
    	&lt;/step>
    &lt;/job>    </programlisting>
      <para>This creates a pool of 8 threads which will attempt to read the file in parallel. By
        default the tasklet throttles at 4 concurrent threads of operation (even if the task
        executor has more available) so we need to explicitly raise it if we wish to use
        more.</para>
      <para>As the chunks are processed in parallel there is no longer any guarantee that the order
        of records output will match the input order. Internally there are 2 main points of
        synchronisation - where character data is read from the source file and where it is written
        to the destination file. The C24ItemReader &amp; Writer attempt to do as much work as
        possible outside of these boundaries (so for example where an elementStartPattern is
        specificied the only logic inside the reading synchronisation point is to read data until a
        matching line is encountered; all interpretation of that data takes place outside of the
        synchronised block).</para>
    </section>
  </section>
</chapter>