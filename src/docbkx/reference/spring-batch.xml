<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="spring-batch">
  <title>C24 IO support for Spring Batch</title>
  <abstract>
    <para>Spring Batch provides an extension of the Spring programming model to enable the
      development of robust batch applications vital for the daily operations of enterprise
      systems.Â C24 IO components for Spring Batch makes C24 parsing, validation and transformation
      directly usable as Spring Batch components.</para>
  </abstract>
  <section id="intro">
    <title>Introduction</title>
    <para>C24 IO Spring Batch support extends the Spring Batch Core with implementations of
      ItemReaders &amp; ItemProcessors designed to make it easy to work with C24 IO generated types,
      transforms and data in Spring Batch jobs.</para>
    <para>This guide assumes the reader is familiar with Spring and Spring configuration; please
      review the documentation at SpringSource if not.</para>
    <para>This guide will emphasise the use of Spring XML namespaces to configure C24 IO Spring
      components although other standard Spring configuration constructs are available. In general a
      minimal namespace would look like:
      <programlisting language="xml">&lt;beans:beans xmlns="http://www.springframework.org/schema/batch" 
     xmlns:beans="http://www.springframework.org/schema/beans" 
     xmlns:c24="http://schema.c24.biz/spring-core"
     xmlns:bat-c24="http://schema.c24.biz/spring-batch"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="
         http://schema.c24.biz/spring-core           
         http://schema.c24.biz/spring-core.xsd
         http://schema.c24.biz/spring-batch          
         http://schema.c24.biz/spring-batch.xsd
         http://www.springframework.org/schema/beans 
         http://www.springframework.org/schema/beans/spring-beans.xsd
         http://www.springframework.org/schema/batch 
         http://www.springframework.org/schema/batch/spring-batch.xsd"></programlisting></para>
  </section>
  <section id="parsing">
    <title>Parsing &amp; Validation</title>
    <para>C24 Spring Batch provides an <interface>ItemReader</interface> that reads data from a
      source and parses the result into a C24 model.</para>
    <para>The first stage is to identify the model which represents the unparsed data. Using the C24
      Spring Core namespace, the model bean can be declared as:</para>
    <para>
      <programlisting language="xml">&lt;c24:model id="demoModel" base-element="biz.c24.demo.model.MyElement"/></programlisting>
    </para>
    <para>where <classname>biz.c24.demo.model.MyElement</classname> is the top-level
        <classname>Element</classname> class generated by C24 IO for your model. </para>
    <para>Remember that the Spring Batch paradigm effectively streams elements from the data source,
      thus the model class is the <classname>Element</classname> of the individual element and not
      the containing one; for examples if you have a file containing multiple Receipts, you may
      generate a Receipt type to model the receipt and a Receipts type (containing zero or more
      Receipt) to model the file - we would use the ReceiptElement in this case (and not the
      ReceiptsElement).</para>
    <para>In its current form thefore, the ItemReader is better suited for fixed length or delimited
      files (e.g. CSV) than it is for hierarchical files (e.g. XML) although the splitting
      capability (see below) may be able to take care of these concerns.</para>
    <section>
      <title>C24ItemReader</title>
      <para>The C24ItemReader can be used as a standard ItemReader in any Spring Batch flow.
        Assuming the namespace declarations above, it is instantiated as:</para>
      <para>
        <programlisting language="xml">&lt;bat-c24:item-reader id="ioItemReader" 
                     model-ref="demoModel" 
                     source-ref="fileSource" 
                     elementStartPattern="..." 
                     elementStopPattern="..." 
                     validate="true" 
                     failfast="true"
                     source-factory-ref="..."
                     parse-listener-ref="..." 
                     scope="step">
    &lt;bat-c24:file-source skip-lines="..." resource="..." encoding="..."/>
&lt;/bat-c24:item-reader></programlisting>
      </para>
      <para>In order, these attributes are:</para>
      <para>
        <itemizedlist>
          <listitem>
            <para><emphasis>id</emphasis> - id of the bean, used to refer to it later in the job
              configuration</para>
          </listitem>
          <listitem>
            <para><emphasis>model-ref</emphasis> - the id of the model we declared earlier
              [Mandatory]</para>
          </listitem>
          <listitem>
            <para><emphasis>source-ref</emphasis> - the id of the source from which we'll read data
              [Exclusive with the nested file-source element]</para>
          </listitem>
          <listitem>
            <para><emphasis>elementStartPattern</emphasis> - a regular expression used to speed up
              parsing performance by identifying the start of an element [Optional]</para>
          </listitem>
          <listitem>
            <para><emphasis>elementStopPattern</emphasis> - a regular expression used to speed up
              parsing performance by identifying the end of an element [Optional]</para>
          </listitem>
          <listitem>
            <para><emphasis>validate</emphasis> - whether or not to validate the parsed object
              [Optional - default false]</para>
          </listitem>
          <listitem>
            <para><emphasis>failfast</emphasis> - if validation is enabled, whether to fail on the
              first validation error (true) or to capture all validation errors before failing
              (false) [Optional - default true]</para>
          </listitem>
          <listitem>
            <para><emphasis>source-factory-ref</emphasis> - the iO SourceFactory that is used to
              parse the message [Optional - default is to use the model's default source]</para>
          </listitem>
          <listitem>
            <para><emphasis>parse-listener-ref</emphasis> - a listener which will be invoked at key
              points during the parsing process [Optional - default is none]</para>
          </listitem>
          <listitem>
            <para><emphasis>scope</emphasis> - the bean's scope [Optional - default step]</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>If validation is selected then a ValidationManager will be used to check all parsed
          <classname>ComplexDataObject</classname>s, and a
          <classname>C24ValidationException</classname> will be thrown in the event of any
        validation failures. If <emphasis>failfast</emphasis> is false and there are multiple
        validation failures a <classname>C24CompoundValidationException</classname> (which extends
          <classname>C24ValidationException</classname>) will be thrown. Callers can use the
          <methodname>getFailures</methodname> method to retrieve all of the
          <classname>ValidationEvent</classname>s that caused validation to fail.</para>
      <para>If all reads (and validations if enabled) are successful then the ItemReader will return
        null once there is no data left to parse (in the case of the zip file, all contained files
        will be parsed before this happens).</para>
      <para>The <classname>C24ItemReader</classname> bean defaults to a <emphasis>scope</emphasis>
        of 'step' to ensure that concurrent invocations of the same step do not conflict with
        eachother. This can be overriden if desired but is not recommended.</para>
      <para>At this time the <classname>C24ItemReader</classname> does not provide support for
        resuming a job (ie via tracking progress through its source in the
          <classname>StepContext</classname>) however it does support both
          <emphasis>task-executors</emphasis> (for multi-threaded processing) and chunks. Setting
        the chunk size appropriately means that the parsing, validation &amp; transformation can run
        with relatively low memory consumption even with extremely large source files.</para>
      <para>During the parsing phase, exceptions thrown by the iO generated code will be wrapped up
        as Spring Batch <classname>ParseException</classname> or
          <classname>NonTransientResourceExceptions</classname> (at least, as best as the ItemReader
        can determine) and rethrown.</para>
      <section>
        <title>C24XmlItemReader</title>
        <para>For XML messages a variant of the <classname>C24ItemReader</classname> is available
          which changes how the splitting process works. Its attributes are identical to those of
          the <classname>C24ItemReader</classname> and its behaviour will only differ in the event
          that an <emphasis>elementStartPattern</emphasis> is specified. Please see the Splitting
          section below for more details on how the <classname>C24XmlItemReader</classname> splits
          input data. The ItemReader is instantiated as:</para>
        <para>
          <programlisting language="xml">&lt;bat-c24:xml-item-reader id="ioXmlItemReader" 
                     model-ref="demoModel" 
                     source-ref="fileSource" 
                     elementStartPattern="..." 
                     elementStopPattern="..." 
                     validate="true" 
                     failfast="true"
                     source-factory-ref="..."
                     parse-listener-ref="..." 
                     scope="step">
    &lt;bat-c24:file-source skip-lines="..." resource="..." encoding="..."/>
&lt;/bat-c24:xml-item-reader></programlisting>
        </para>
      </section>
    </section>
    <section>
      <title>Sources</title>
      <para>The C24 ItemReader needs a source from which to read its data. Currently there are 2
        supported sources:<itemizedlist>
          <listitem>
            <para><classname>biz.c24.io.spring.batch.reader.source.FileSource</classname></para>
          </listitem>
          <listitem>
            <para><classname>biz.c24.io.spring.batch.reader.source.ZipFileSource</classname></para>
          </listitem>
        </itemizedlist>The first of these reads from a single, uncompressed file<footnoteref
          linkend="FileSource" xreflabel="FileSource"/> while the latter accepts a zip file as input
        and will process the contents of all contained entries.</para>
      <para>
        <footnote id="FileSource">
          <para>Although the <classname>FileSource</classname> is explicitly intended to work with
            files, internally it only requires an <interfacename>InputStream</interfacename> from
            its <interfacename>Resource</interfacename>. In theory therefore other types of resource
            can be used with this source so long as they return a valid input stream from
              <methodname>getInputStream</methodname> and a valid value from their
              <methodname>getFilename</methodname> method (which the
              <classname>FileSource</classname> uses to provide contextual information).</para>
          <para>In contrast, the <classname>ZipFileSource</classname> invokes the
              <methodname>getFile</methodname> method on the supplied
              <classname>Resource</classname>.</para>
        </footnote>
      </para>
      <para>Although the sources can be explicitly constructed<footnoteref linkend="ExplicitSource"
        /> and associated with the C24ItemReader via the <emphasis>source-ref</emphasis> attribute,
        it is more common to declare sources as child elements of the ItemReader:</para>
      <para>
        <footnote id="ExplicitSource">
          <para>If you do choose to explicitly construct the source, be sure to set the scope of the
            bean correctly. For most cases, you will want to set the scope to "step" as the sources
            hold state relevant to the current step execution. Indeed this is required if you wish
            to use late binding to any <interfacename>Job</interfacename> or
              <interfacename>Step</interfacename>-specific objects in your resource definition.
          </para>
        </footnote>
      </para>
      <para>
        <programlisting language="xml">&lt;bat-c24:item-reader ... >
<emphasis role="bold">    &lt;bat-c24:file-source skip-lines="..." resource="..." encoding="..."/></emphasis>
&lt;/bat-c24:item-reader></programlisting>
      </para>
      <para>or for a ZipFileSource:</para>
      <para>
        <programlisting language="xml">&lt;bat-c24:item-reader ... >
<emphasis role="bold">    &lt;bat-c24:zip-file-source skip-lines="..." resource="..." encoding="..."/></emphasis>
&lt;/bat-c24:item-reader></programlisting>
      </para>
      <para>The attributes are the same for both sources:</para>
      <para>
        <itemizedlist>
          <listitem>
            <para><emphasis>skip-lines</emphasis> - the number of lines to skip over at the start of
              the file (start of each file within the zip in the case of the
                <classname>ZipFileSource</classname>). [Optional - default zero]</para>
          </listitem>
          <listitem>
            <para><emphasis>resource</emphasis> - a Spring <interfacename>Resource</interfacename>
              to use to determine the file to read from. [Optional - defaults to reading file path
              from a <classname>JobParameter</classname> called
              <emphasis>input.file</emphasis>]</para>
          </listitem>
          <listitem>
            <para><emphasis>encoding</emphasis> - the character set encoding to use when reading
              from the file. [Optional - defaults to UTF-8]</para>
          </listitem>
          <listitem>
            <para><emphasis>consistent-line-terminators</emphasis> - if we know that every line in a
              file uses the same line terminator, we may be able to optimise the splitting process
              slightly (see below) [Optional - defaults to true]</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>Both sources derive their input from a Spring Resource. The resource can be set directly
        on the <interfacename>Source</interfacename>, for example:</para>
      <para>
        <programlisting language="xml">&lt;bat-c24:item-reader ... >
    &lt;bat-c24:file-source resource="/tmp/data.csv"/>
&lt;/bat-c24:item-reader></programlisting>
      </para>
      <para>In many cases, the filename we need to process will be different on each invocation of
        the job. Spring's late binding capability allows far greater flexibility on how the
        parameter is set. For example, the Spring Batch Admin
          <classname>org.springframework.batch.admin.integration.FileToJobLaunchRequestAdapter</classname>
        creates a Job with a <classname>JobParameter</classname> called
          '<emphasis>input.file</emphasis>'. We can create a <classname>ZipFileSource</classname>
        that will use the contents of this parameter as follows:</para>
      <para>
        <programlisting language="xml">&lt;bat-c24:item-reader ... >
    &lt;bat-c24:zip-file-source resource="#{jobParameters['input.file']}"/>
&lt;/bat-c24:item-reader></programlisting>
      </para>
      <para>In fact, both the <classname>FileSource</classname> and the
          <classname>ZipFileSource</classname> fall back to looking for a
          <classname>JobParameter</classname> call <emphasis>input.file</emphasis> if you don't
        supply them with a <classname>Resource</classname>, however we recommend using the explicit
        declaration above to aid future maintainers of your configuration.</para>
      <para>Both the <classname>FileSource</classname> and the <classname>ZipFileSource</classname>
        allow the first n lines of each file they encounter to be skipped (in the case of the
          <classname>ZipFileSource</classname>, the first n lines of each file within the Zip file).
        For example to skip a one line header at the start of each file, the
          <classname>FileSource</classname> would be configured as:</para>
      <programlisting language="xml">&lt;bat-c24:item-reader ... >
    &lt;bat-c24:file-source skip-lines="1" resource="..."/>
&lt;/bat-c24:item-reader></programlisting>
      <para>The <interface>Sources</interface> provide guidance to the
          <classname>C24ItemReader</classname> on how it should process the Source in the event that
        multiple threads are concurrently invoking <methodname>read</methodname> on it. By default
        each file will be processed serially, however in the case of a zip file containing multiple
        entries:</para>
      <para>
        <itemizedlist>
          <listitem>
            <para>If the zip file contains more than 20 entries and the first entry is less than
              100,000 bytes (or of indeterminate size) use 1 thread per entry</para>
          </listitem>
          <listitem>
            <para>Otherwise all threads process the same entry until it is exhausted, at which point
              they move on to the next one</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>The former has the advantage of less synchronisation between threads during the read
        phase (as only one thread can be reading from a zip entry at any time) at the potential cost
        of increased seeking as data is requested from different parts of the zip file by multiple
        threads.</para>
    </section>
    <section>
      <title>Splitting</title>
      <para>For complex models, parsing can be a relatively expensive operation. The
          <classname>C24ItemReader</classname> allows multiple threads to be consuming data from it
        concurrently, however as by default an element needs to be fully parsed before the start
        point of the next element in the file can be determined, this part of the process
        effectively becomes single-threaded as each thread blocks waiting to be able to read from
        the input source (validation can always be performed in parallel however).</para>
      <para>The <classname>C24ItemReader</classname> supports an optional
          '<emphasis>elementStartPattern</emphasis>' regular expression (as defined by Java's
        Pattern class) to allow individual elements to be rapidly 'split' out of the inbound data
        stream so subequent parsing operations can take place in parallel. While the splitting is
        also a single-threaded activity it is usually much faster than a full parse and hence allows
        more of the process to happen in parallel.</para>
      <para>The <emphasis>elementStartPattern</emphasis> is used to detect the first line in a new
        element. When the ItemReader sees a matching line, it starts a new element with that line as
        its initial line. If the ItemReader was already in the process of reading an element, that
        element will be deemed to be complete and a new element will be started with the matching
        line. The ItemReader will skip all lines at the start of a file until it finds a line that
        matches the elementStartPattern. Thus the splitter can also be used to skip header rows, by
        ensuring that they do not match the pattern. </para>
      <para>Where an <emphasis>elementStartPattern</emphasis> has been specified, an
          <emphasis>elementStopPattern</emphasis> can also optionally be used. In this case, rather
        than using the <emphasis>elementStartPattern</emphasis> to infer the end of the previous
        element, an element is only deemed to be complete when either a line matching the
          <emphasis>elementStopPattern</emphasis> is encountered or the parser reaches the end of
        the file. Thus the <emphasis>elementStopPattern</emphasis> takes precedence over the
          <emphasis>elementStartPattern</emphasis> and it is possible for there to be multiple lines
        matching the <emphasis>elementStartPattern</emphasis> with a single element.</para>
      <para>Both <emphasis>elementStartPattern</emphasis> and
          <emphasis>elementStopPattern</emphasis> are inclusive; on other words the lines that match
        them are included in the element.</para>
      <para>Splitting is line-based. In other words it is not supported for an individual line to
        form part of 2 different elements (either in part or in its entirely).</para>
      <para>A typical use case would be to split child elements out of an XML document. By having
        the start and stop patterns match the initiator ("&lt;child ...") and terminator
        ("&lt;/child>") of the elements, they can be extracted without having to also process their
        containing element.</para>
      <para>The <classname>C24ItemReader</classname> splits input data into lines by detecting line
        terminators. The current implementation supports the following line terminators:</para>
      <para>
        <itemizedlist>
          <listitem>
            <para>\r\n</para>
          </listitem>
          <listitem>
            <para>\r</para>
          </listitem>
          <listitem>
            <para>\n</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>Note that the line will include any line terminators hence the regular expressions used
        in <emphasis>elementStartPattern</emphasis> and <emphasis>elementStopPattern</emphasis> will
        need to match those too. To make this process slightly easier, the
          <emphasis>DOTALL</emphasis> flag is set during pattern compilation (i.e. the '.' regular
        expression character will also match line terminators).</para>
      <section>
        <title>XML and Splitting</title>
        <para>The process of splitting data on line terminators may be problematic for XML files
          which are not traditionally formatted. Consequently the C24XmlItemReader instead splits
          input data up into lines around the '&lt;' character. For example:</para>
        <para>
          <programlisting language="xml">&lt;receipt id="1">&lt;item product="1" value="10">Carrots&lt;/item>&lt;/receipt></programlisting>
        </para>
        <para>would be split into the following 'lines':</para>
        <para>
          <programlisting language="xml">&lt;receipt id="1">
&lt;item product="1" value="10">Carrots
&lt;/item>
&lt;/receipt></programlisting>
        </para>
        <para>In order to keep the splitting process fast (to minimise contention between threads)
          the splitting process does not examine the structure of the XML and will therefore match
          and split on <emphasis>any</emphasis> '&lt;' character, including for example those in
          CDATA sections. As per with the regular splitter, any line terminators in the input will
          be preserved in the output.</para>
      </section>
    </section>
    <section>
      <title>Validation</title>
      <para>If enabled via the '<emphasis>validate</emphasis>' attribute, the
          <classname>C24ItemReader</classname> will use a <classname>ValidationManager</classname>
        to validate the parsed <classname>ComplexDataObject</classname>. In the event of a
        validation failure, the iO exception will be wrapped and rethrown as a type derived from the
        Spring Batch <classname>ValidationException</classname>. By default validation of an object
        will abort on the first failure. If instead you wish to catch a compound exception which
        contains all failures, set the optional <emphasis>failfast</emphasis> attribute to
        false.</para>
    </section>
    <section>
      <title>Intercepting the Parsing Process</title>
      <para>Callers can register a
          <interfacename>biz.c24.io.spring.batch.reader.ParseListener</interfacename> with the
          <classname>C24ItemReader</classname> in order to add custom logic to the parsing process.
        There are 3 key interaction points:</para>
      <para>
        <itemizedlist>
          <listitem>
            <para>As each line is read from the <interfacename>Source</interfacename> [only
              available where Splitting is being used]. This can be used for informational purposes
              (e.g. to extract contextual information from the file beyond the elements that are
              being parsed), or to influence the parsing process as the callback allows the line to
              the modified.</para>
          </listitem>
          <listitem>
            <para>As each element is extracted from the <interfacename>Source</interfacename> [only
              available where Splitting is being used]. Allows the callback to associate context
              with the element.</para>
          </listitem>
          <listitem>
            <para>Before the parsed <classname>ComplexDataObject</classname> is returned from the
                <classname>C24ItemReader</classname>. Allows the
                <classname>ComplexDataObject</classname> to be modified or the object to be wrapped
              before it is passed to downstream processors.</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>An example usage would be where the <classname>C24ItemReader</classname> is extracting
        child elements from an XML file however the downstream
          <interfacename>ItemProcessor</interfacename>s or<interfacename>
        ItemWriter</interfacename>s required additional context from the parent elements. In this
        case the ParseListener logic would be:</para>
      <para>
        <itemizedlist>
          <listitem>
            <para>Extract and cache the parent information in the
                <methodname>processLine</methodname> callback</para>
          </listitem>
          <listitem>
            <para>Supply the cached information back to the <classname>C24ItemReader</classname> in
              the <methodname>getContext</methodname> call</para>
          </listitem>
          <listitem>
            <para>Combine the <classname>ComplexDataObject</classname> and the cached context in the
                <methodname>process</methodname> call</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>Please note that while it is safe for a step-scoped ParserListener to use information
        cached from the processLine callback in the getContext call in most circumstances, there are
        cases where these methods will not see a purely linear view of a file (for example where
        processing zip files, it is possible for multiple entries to be processed concurrently).
        While the current listener interface does not allow listeners to determine explicitly which
        ZipEntry (or Reader) the current line or element was parsed from, in these circumstances it
        might be possible to use ThreadLocal storage to achieve the same goals.</para>
    </section>
  </section>
  <section>
    <title>Transformation</title>
    <para>iO-generated transformations can be used in Spring Batch as ItemProcessors. The
        <classname>C24TransformItemProcessor</classname> takes in a raw iO-generated transform and
      exposes it via a <interface>ItemProcessor</interface> interface:</para>
    <para>
      <programlisting language="xml">&lt;beans:bean id="demoTransform" class="biz.c24.demo.DemoTransform"/>

&lt;bat-c24:transform-item-processor id="ioItemProcessor" 
                                  transform-ref="demoTransform" 
                                  validate="true"
                                  failfast="true" /></programlisting>
    </para>
    <para>Or equivalently in Java:</para>
    <para>
      <programlisting language="java">@Bean 
public C24TransformItemProcessor getIoItemProcessor() { 
  return new C24TransformItemProcessor(new DemoTransform(), true, true); 
}</programlisting>
    </para>
    <para>The result of the transformation will also be a <classname>ComplexDataObject</classname>,
      but its <classname>ComplexDataType</classname> will be that of the destination type.</para>
    <para>The <classname>C24TransformItemProcessor</classname> also supports an optional
        <emphasis>target-class</emphasis> attribute. If specified, instead of returning a
        <classname>ComplexDataObject</classname> derirved object, the transformer will attempt to
      transform to the class specified using iO's <classname>JavaSink</classname>. The target class
      must be a valid Java Bean class whose properties match those of the transform's target model.
      For example:</para>
    <para>
      <programlisting language="xml">&lt;bat-c24:transform-item-processor id="ioItemProcessor" 
                                  transform-ref="demoTransform" 
                                  target-class="My.JavaBeanClass"/></programlisting>
    </para>
    <para>will attempt to return an object of type My.JavaBeanClass, throwing an exception if the
      target class does not provide the necessary API. For instance, if the target model was
      originally imported from a Java class, the original Java class could be used as the
        <emphasis>target-class</emphasis>.</para>
    <para>Note that if the <emphasis>target-class</emphasis> attribute is used and the specified
      type is not derived from <classname>ComplexDataObject</classname>, downstream C24 components
      which expect a <classname>ComplexDataObject</classname> as input (such as the
        <classname>C24TransformItemProcessor</classname> itself and the
        <classname>C24ItemWriter</classname>) cannot be used.</para>
    <section>
      <title>Validation</title>
      <para>The <classname>C24TransformItemProcessor</classname> can also optionally validate the
        resultant <classname>ComplexDataObject</classname> using a validation manager. To enable
        this functionality, set the '<emphasis>validate</emphasis>' attribute on the processor to
        true, optionally also setting the <emphasis>failfast</emphasis> attribute.</para>
      <para>The processor will throw an exception if validation fails, with the same behaviour as
        described in the <classname>C24ItemReader</classname>'s validation documentation.</para>
    </section>
  </section>
  <section>
    <title>Writing</title>
    <para>C24 iO Components for Spring Batch provides a convenient mechanism to write a
        <classname>ComplexDataObject</classname> through a <interfacename>Sink</interfacename> to a
        <classname>java.io.Writer</classname>. As with the <classname>C24ItemReader</classname>, the
        <classname>C24ItemWriter</classname> also decouples the external container to allow multiple
      potential (types of) destination to be supported.</para>
    <section>
      <title>C24ItemWriter</title>
      <para>The <classname>C24ItemWriter</classname> wraps a <interfacename>Sink</interfacename>
        &amp; a <interfacename>WriterSource</interfacename>. It is declared as:</para>
      <para>
        <programlisting language="xml">&lt;beans:bean id="textualSink" class="biz.c24.io.api.presentation.TextualSink"/>

&lt;bat-c24:item-writer id="..." 
                     sink-ref="textualSink" 
                     writer-source-ref="...">
    &lt;bat-c24:file-writer resource="..." encoding="..."/>
&lt;/bat-c24:item-writer>   </programlisting>
      </para>
      <para>The available attributes are:<itemizedlist>
          <listitem>
            <para><emphasis>id</emphasis> - The id of the <classname>C24ItemWriter</classname> (used
              when declaring the chunk)</para>
          </listitem>
          <listitem>
            <para><emphasis>sink-ref</emphasis> - The id of the iO <interface>Sink</interface> to
              use to marshall the <classname>ComplexDataObject</classname> [Mandatory]</para>
          </listitem>
          <listitem>
            <para><emphasis>writer-source-ref</emphasis> - The id of the
                <interface>WriterSource</interface> to use [Exclusive with
                <emphasis>file-writer</emphasis> child element]</para>
          </listitem>
          <listitem>
            <para><emphasis>scope</emphasis> - The bean scope [Optional - default Step]</para>
          </listitem>
        </itemizedlist></para>
      <para>The bean has a default <emphasis>scope</emphasis> of 'step' as its embedded
          <interface>WriterSource</interface> is likely to store instance-specific data; this can of
        course be overriden but is not recommended.</para>
      <para>Internally when write is called, the <classname>C24ItemWriter</classname> will sink all
        supplied <classname>ComplexDataObject</classname>s into an internal structure before
        acquiring a <interfacename>Writer</interfacename> from the
          <interface>WriterSource</interface> and writing the resultant data in a single blocking
        call. This means that while elements within a chunk will remain in the same order that the
          <classname>C24ItemWriter</classname> received them, if the writer is being exercised in
        parallel (e.g. the parent Tasklet has a <emphasis>task-executor</emphasis>) there is no
        guarantee that the chunks themselves will be written in order. If absolute ordering is
        imperative, the entire step must be run single-threaded.</para>
    </section>
    <section>
      <title>WriterSources</title>
      <para>The C24 ItemWrtier needs to know where to write the output from the
          <interfacename>Sink</interfacename>. The following implementations are available in the distribution:<itemizedlist>
          <listitem>
            <para><classname>biz.c24.io.spring.batch.writer.source.FileWriterSource</classname></para>
          </listitem>
          <listitem>
            <para><classname>biz.c24.io.spring.batch.writer.source.ZipFileWriterSource</classname></para>
          </listitem>
        </itemizedlist></para>
      <para>As with the <classname>C24ItemReader</classname> sources, while
          <interfacename>WriterSource</interfacename>s can be declared explicitly<footnoteref
          linkend="ExplicitWriterSource"/> and wired into the <classname>C24ItemWriter</classname>
        via the <emphasis>writer-source-ref</emphasis> attribute, it is more common to declare them
        as child elements:</para>
      <para>
        <footnote>
          <para id="ExplicitWriterSource">As with the <classname>C24ItemReader</classname>
            <interfacename>Source</interfacename>s, you will almost certainly want to set the scope
            of any explicitly declared beans to "<emphasis>step</emphasis>".</para>
        </footnote>
      </para>
      <para>
        <programlisting language="xml">&lt;bat-c24:item-writer ... >
<emphasis role="bold">    &lt;bat-c24:file-writer resource="..." encoding="..."/></emphasis>
&lt;/bat-c24:item-writer></programlisting>
      </para>
      <para>for a <classname>FileWriterSource</classname> or:</para>
      <para>
        <programlisting language="xml">&lt;bat-c24:item-writer ... >
<emphasis role="bold">    &lt;bat-c24:zip-file-writer resource="..." encoding="..."/></emphasis>
&lt;/bat-c24:item-writer></programlisting>
      </para>
      <para>for a <classname>ZipFileWriterSource</classname>.</para>
      <para>The supported attributes for both the <classname>FileWriterSource</classname> and
          <classname>ZipFileWriterSource</classname> are:</para>
      <para>
        <itemizedlist>
          <listitem>
            <para><emphasis>resource</emphasis> - a Spring <interfacename>Resource</interfacename>
              to use to determine the file to write to. [Optional - defaults to reading file path
              from a <classname>JobParameter</classname> called
              <emphasis>output.file</emphasis>]</para>
          </listitem>
          <listitem>
            <para><emphasis>encoding</emphasis> - the character set encoding to use when writing to
              the file. [Optional - defaults to UTF-8]</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>The <classname>FileWriterSource</classname> writes all data to a single file, without
        any limits on the file size. It determines the file to write from a supplied
          <classname>FileSystemResource</classname> or, if not specified, a
          <classname>JobParameter</classname> called '<emphasis>output.file</emphasis>'. Definition
        of the resource is exactly as described above for the <classname>C24ItemReader</classname>
        <interfacename>Source</interfacename>s with the exception that the
          <interfacename>Resource</interfacename> type must be a
          <classname>FileSystemResource</classname>. For example:</para>
      <para>
        <programlisting language="xml">&lt;bat-c24:item-writer ... >
<emphasis role="bold">    &lt;bat-c24:file-writer resource="/tmp/data.csv"/></emphasis>
&lt;/bat-c24:item-writer></programlisting>
      </para>
      <para>Or to use the <emphasis>output.file</emphasis>
        <classname>JobParameter</classname>:</para>
      <para>
        <programlisting language="xml">&lt;bat-c24:item-writer ... >
<emphasis role="bold">    &lt;bat-c24:zip-file-writer resource="#{jobParameters[output.file']}"/></emphasis>
&lt;/bat-c24:item-writer></programlisting>
      </para>
      <para>See the <classname>FileSource</classname> documentation under Reading for other examples
        on how the <classname>Resource</classname> can be set.</para>
      <para>The <classname>ZipFileWriterSource</classname> behaves identically except that it will
        create a zip file (thus the filename supplied in the <classname>Resource</classname> or
          <emphasis>output.file</emphasis> should end with .zip) with a single entry, named after
        the filename with any leading path and the file suffix stripped off.</para>
    </section>
  </section>
  <section>
    <title>Examples</title>
    <para>The following is a minimal set-up for trying out the C24 Spring Batch components. It sets
      up a basic job repository, transaction manager &amp; launcher. These are purely in-memory,
      minimum effort implementations and are unlikely to be sufficient for most practical purposes;
      please see the Spring Batch documentation for approrpriate alternatives.</para>
    <para>The code shown in this section and sample data are included in the c24-sample-springbatch
      example on GitHub: <ulink url="https://github.com/C24-Technologies/c24-sample-springbatch"
        >https://github.com/C24-Technologies/c24-sample-springbatch </ulink></para>
    <programlisting language="xml">&lt;beans:beans xmlns="http://www.springframework.org/schema/batch" 
     xmlns:beans="http://www.springframework.org/schema/beans" 
     xmlns:c24="http://schema.c24.biz/spring-core"
     xmlns:bat-c24="http://schema.c24.biz/spring-batch"
     xmlns:task="http://www.springframework.org/schema/task"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="
        http://schema.c24.biz/spring-core            
        http://schema.c24.biz/spring-core.xsd
        http://schema.c24.biz/spring-batch           
        http://schema.c24.biz/spring-batch.xsd
        http://www.springframework.org/schema/task   
        http://www.springframework.org/schema/task/spring-task.xsd
        http://www.springframework.org/schema/beans  
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/batch  
        http://www.springframework.org/schema/batch/spring-batch.xsd">
    
    &lt;!-- A no-op transaction manager -->
    &lt;beans:bean id="transactionManager" class=
         "org.springframework.batch.support.transaction.ResourcelessTransactionManager"/>

    &lt;!-- An in-memory job repository -->
    &lt;beans:bean id="jobRepository" class=
         "org.springframework.batch.core.repository.support.MapJobRepositoryFactoryBean"/>

    &lt;!-- A simple job launcher which kicks off tasks asynchronously -->
    &lt;beans:bean id="jobLauncher" 
                class="org.springframework.batch.core.launch.support.SimpleJobLauncher">
        &lt;beans:property name="jobRepository" ref="jobRepository" />
        &lt;beans:property name="taskExecutor">
            &lt;beans:bean class="org.springframework.core.task.SimpleAsyncTaskExecutor"/>
        &lt;/beans:property>
     &lt;/beans:bean>
&lt;/beans:bean></programlisting>
    <section>
      <title>A Basic Parsing C24 IO Spring Batch Job</title>
      <para>Now that we have the basic scaffolding in place, we can declare our C24 Spring Batch
        beans. First the
        <interface>ItemReader</interface>:<programlisting language="xml">    &lt;c24:model id="employeeModel" 
               base-element="biz.c24.io.examples.models.basic.EmployeeElement"/>

    &lt;bat-c24:item-reader id="ioItemReader" 
                         model-ref="employeeModel" 
                         elementStartPattern=".*" 
                         validate="true">
        &lt;bat-c24:file-source resource="#{jobParameters['input.file']}" />
    &lt;/bat-c24:item-reader></programlisting></para>
      <para>replacing <code>biz.c24.io.examples.models.basic.EmployeeElement</code> with the fully
        qualified path to your generated model Element. The <emphasis>elementStartPattern</emphasis>
        shown above assumes that each element that we're going to read from the source file is
        contained on a single line and that there are no header or comment lines (i.e. every line is
        an element).</para>
      <para>Now we define a simple job to read (and implicitly validate)
          <classname>ComplexDataObject</classname>s from our source:</para>
      <para>
        <programlisting language="xml">    &lt;job id="fileLoader">
        &lt;step id="parseFile">
            &lt;tasklet>
                &lt;chunk reader="ioItemReader" 
                       writer="ioItemWriter" 
                       commit-interval="100"/>
            &lt;/tasklet>
        &lt;/step>
    &lt;/job></programlisting>
      </para>
      <para>This has:<itemizedlist>
          <listitem>
            <para>Created a job called fileLoader</para>
          </listitem>
          <listitem>
            <para>Added a single step called parseFile</para>
          </listitem>
          <listitem>
            <para>Read items (<classname>ComplexDataObject</classname>s) from our ioItemReader bean
              then once it has read 100 items (the commit-interval) it will pass all of them to an
              ItemWriter in a single invocation. Most writers will work more efficiently if they are
              called with an appropriately sized batch of items (particularly where transactions are
              involved).</para>
          </listitem>
        </itemizedlist></para>
      <para>We'll come back to the writer attribute shortly, but normally it will be specific to
        your application as you hand off the parsed &amp; validated objects to downstream
        processing. If you're using the c24-sample-springbatch example application you can use the
        supplied <classname>ConsoleItemWriter</classname> to write the
          <classname>ComplexDataObject</classname> to the console:</para>
      <para>
        <programlisting language="xml">  &lt;beans:bean id="ioItemWriter" class="biz.c24.batchdemo.writers.ConsoleWriter"/></programlisting>
      </para>
      <para>Now it's time to launch our job and see it working. Normally job triggering would be
        handled by the framework; for now we'll launch it manually:</para>
      <para>
        <programlisting language="java">    public static void main(String[] args) throws JobExecutionAlreadyRunningException, 
                                                  JobRestartException, 
                                                  JobInstanceAlreadyCompleteException, 
                                                  JobParametersInvalidException, 
                                                  IOException {
        
        // Create our application context - 
        // assumes the Spring configuration is in the classpath 
        // in a file called spring-config.xml
        ApplicationContext context = 
            new ClassPathXmlApplicationContext("spring-config.xml");
        
        // Get the job from our Spring context
        Job job = context.getBean("parseFile", Job.class);

        // .. and a single JobLauncher bean
        JobLauncher jobLauncher = context.getBean(JobLauncher.class);
        
        // Create the job parameters and supply the name of the file to parse
        Map&lt;String, JobParameter> params = new HashMap&lt;String, JobParameter>();

        // The C24ItemReader is configured to get the filename from a job parameter called input.file
        // (see src/main/resources/spring-config.xml)
        // In this case, the file is in the classpath and is called employees-3-valid.csv
        params.put("input.file", new JobParameter("classpath:/employees-3-valid.csv"));

        JobParameters jobParameters = new JobParameters(params);

        // Launch the job!
        jobLauncher.run(job, jobParameters);

    }</programlisting>
      </para>
      <para>If you're using the sample data from the c24-sample-springbatch example you should see
        the following written to the console:</para>
      <para>
        <programlisting>Mr,Andy,Acheson,Software Developer
Mr,Joe,Bloggs,Security Guard
Mr,Greg,Gatsby,Managing Director</programlisting>
      </para>
      <para>There are numerous other potential attributes that can be set on the chunk &amp; tasklet
        (for example, can it be restarted, how many elements need to fail to parse/validate before
        the entire job should be abandoned etc); please see the Spring Batch documentation for
        further detail.</para>
    </section>
    <section>
      <title>Adding a Transform</title>
      <para>Wiring in a Transform simply requires additional configuration. The example code
        includes an <classname>EmployeeToEmailTransform</classname> which we'll use to generate an
        email address for each employee.</para>
      <para>Add the following to the Spring configuration:</para>
      <para>
        <programlisting language="xml">    <emphasis role="bold">&lt;beans:bean id="employeeToEmailTransform" 
                 class="biz.c24.io.examples.transforms.basic.EmployeeToEmailTransform"/>

    &lt;bat-c24:transform-item-processor id="transformItemProcessor" 
                                      transform-ref="employeeToEmailTransform" 
                                      validate="true"/></emphasis>
    
    &lt;job id="fileLoader">
        &lt;step id="parseFile">
            &lt;tasklet>
                &lt;chunk reader="ioItemReader" 
                       <emphasis role="bold">processor="transformItemProcessor"</emphasis> 
                       writer="ioItemWriter" 
                       commit-interval="100"/>
            &lt;/tasklet>
        &lt;/step>
    &lt;/job></programlisting>
      </para>
      <para>Now once read and validated, the Employeees will be transformed into Emails and the
        resulting email checked for validity before handing the resulting
          <classname>ComplexDataObject</classname> off to the ItemWriter. Re-run the code with the
        sample data again and you should now see:</para>
      <para>
        <programlisting>A.Acheson@company.com
J.Bloggs@company.com
G.Gatsby@company.com</programlisting>
      </para>
    </section>
    <section>
      <title>Writing Out The Result</title>
      <para>The <classname>ConsoleItemWriter</classname> we've used so far does nothing more than
        call <code>toString()</code> on the <classname>Object</classname>s that are passed to it.
        The <classname>C24ItemWriter</classname> supports a pluggable marshaller
          (<interfacename>Sink</interfacename>) and destination
          (<interfacename>Writer</interfacename>). To finish off the final stage of our example
        application, we'll use iO's <classname>TextualSink</classname> to generate a valid
        representation of our object and write the result to a file.</para>
      <para>First we need to declare the <interfacename>Sink</interfacename>:</para>
      <para><programlisting language="xml">  &lt;beans:bean id="textualSink" 
              class="biz.c24.io.api.presentation.TextualSink"/></programlisting>
        Next we need to declare the <classname>C24ItemWriter</classname>:</para>
      <para>
        <programlisting language="xml">    &lt;bat-c24:item-writer id="ioItemWriter" 
                         sink-ref="textualSink" 
                         writer-source-ref="fileWriterSource">
        &lt;bat-c24:file-writer resource=#{jobParameters['output.file']}" />
    &lt;/bat-c24:item-writer></programlisting>
      </para>
      <para>Finally we update our Step's Chunk to use the new ItemWriter:</para>
      <para>
        <programlisting language="xml">    &lt;job id="fileLoader">
        &lt;step id="parseFile">
            &lt;tasklet>
                &lt;chunk reader="ioItemReader" 
                       processor="transformItemProcessor" 
                       writer="<emphasis role="bold">ioItemWriter</emphasis>" 
                       commit-interval="100"/>
            &lt;/tasklet>
        &lt;/step>
    &lt;/job></programlisting>
      </para>
      <para>Note that we configured the <classname>FileWriterSource</classname> to expect a job
        parameter called <emphasis>output.file</emphasis> to tell it where to write to. We need to
        update our test job launching code to supply this parameter:</para>
      <para>
        <programlisting language="java">        ...

        // The C24ItemReader is configured to get the filename from a job parameter called input.file
        // (see src/main/resources/spring-config.xml)
        // In this case, the file is in the classpath and is called employees-3-valid.csv
        params.put("input.file", new JobParameter(
                                    new ClassPathResource("employees-3-valid.csv")
                                    .getFile().getAbsolutePath()
                                 ));

		// Our C24ItemWriter is configured to expect its output filename in a job parameter called output.file
		// (see src/main/resources/spring-config.xml)        
<emphasis role="bold">        File outputFile = File.createTempFile("RunJob-", ".csv");
        System.out.println("Transforming to " + outputFile.getAbsolutePath());        
        params.put("output.file", new JobParameter(outputFile.getAbsolutePath()));</emphasis>
        
        JobParameters jobParameters = new JobParameters(params);

        ...</programlisting>
      </para>
      <para>The file that the data was written to will be shown on the console, for example:</para>
      <para>
        <programlisting>Transforming to /tmp/RunJob-1050960762367529182.csv</programlisting>
      </para>
      <para>And the contents with the sample data will look like:</para>
      <para>
        <programlisting>A.Acheson@company.com
J.Bloggs@company.com
G.Gatsby@company.com</programlisting>
      </para>
    </section>
    <section>
      <title>Running in Parallel</title>
      <para>When we configured our ItemReader we specified an
          <emphasis>elementStartPattern</emphasis>. This means that as well as validating
          <classname>ComplexDataObject</classname>s in parallel, we can parallelise most of the
        parsing, transforming and writing too. This requires 2 steps: create a task dispatcher pool
        and tell the tasklet to use it:</para>
      <programlisting language="xml">    <emphasis role="bold">&lt;task:executor id="fileLoadingPool" pool-size="8"/></emphasis>
    
    ...

    &lt;job id="fileLoader">
        &lt;step id="parseFile">
            &lt;tasklet <emphasis role="bold">task-executor="fileLoadingPool" throttle-limit="8"</emphasis>>
                &lt;chunk reader="ioItemReader" 
                       processor="transformItemProcessor" 
                       writer="ioItemWriter" 
                       commit-interval="100"/>
            &lt;/tasklet>
        &lt;/step>
    &lt;/job>    </programlisting>
      <para>This creates a pool of 8 threads which will attempt to read the file in parallel. By
        default the tasklet throttles at 4 concurrent threads of operation (even if the task
        executor has more available) so we need to explicitly raise it if we wish to use
        more.</para>
      <para>As the chunks are processed in parallel there is no longer any guarantee that the order
        of records output will match the input order. Internally there are 2 main points of
        synchronisation - where character data is read from the source file and where it is written
        to the destination file. The <classname>C24ItemReader</classname> &amp;
          <classname>C24ItemWriter</classname> attempt to do as much work as possible outside of
        these boundaries (so for example where an <emphasis>elementStartPattern</emphasis> is
        specificied the only logic inside the reading synchronisation point is to read data until a
        matching line is encountered; all interpretation of that data takes place outside of the
        synchronised block).</para>
    </section>
    <section>
      <title>Integration with Spring Integration</title>
      <para>It is often beneficial to be able to move between the Spring Batch &amp; Spring
        Integration worlds within the same flow. Although this process is handled purely by Spring
        Batch &amp; Spring Integration components, the general process is summarised here to provide
        basic guidance.</para>
      <section>
        <title>Launching a Job from Spring Integration</title>
        <para>A common scenario would be that we have an inbound file adapter picking up new files
          from the file system and wish to hand the processing of them over to Spring Batch. This
          requires components from both the Spring Batch Integration project and also the Spring
          Batch Admin project. There are 2 steps in the Spring Integration flow:<itemizedlist>
            <listitem>
              <para>Convert the <classname>java.io.File</classname> received from the
                inbound-file-adapter to a job launch request (including setting the
                  <emphasis>input.file</emphasis> property)</para>
            </listitem>
            <listitem>
              <para>Launch the job</para>
            </listitem>
          </itemizedlist></para>
        <para>In the example code below you'll see the 2 steps above implemented using 2
          service-activators which have been chained together. </para>
        <para>The first one takes a reference to the job that is to be launched; the example below
          launches the fileLoader job from an earlier example.</para>
        <para>The last one returns the status of the launch request; in the code below this is sent
          to a logging adapter but you'll probably want it to go to a monitoring system.</para>
        <para>
          <programlisting language="xml">&lt;beans:beans xmlns="http://www.springframework.org/schema/integration" 
  xmlns:beans="http://www.springframework.org/schema/beans"
  xmlns:int-file="http://www.springframework.org/schema/integration/file"
  xsi:schemaLocation="
    http://www.springframework.org/schema/integration 
    http://www.springframework.org/schema/integration/spring-integration.xsd
    http://www.springframework.org/schema/integration/file 
    http://www.springframework.org/schema/integration/file/spring-integration-file.xsd
    http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">

    &lt;!-- Create an inbound file adapter to watch for files -->
    &lt;int-file:inbound-channel-adapter directory="classpath:" 
                                      filename-pattern="employees-*.csv" 
                                      prevent-duplicates="true" 
                                      channel="inboundEmployeeFile">
    &lt;/int-file:inbound-channel-adapter>
    
    &lt;chain input-channel="inboundEmployeeFile" output-channel="logger">
        &lt;service-activator>
            &lt;beans:bean class=
              "org.springframework.batch.admin.integration.FileToJobLaunchRequestAdapter">
                &lt;beans:property name="job" ref="fileLoader" />
            &lt;/beans:bean>
        &lt;/service-activator>
        &lt;service-activator ref="jobMessageLauncher"/>
    &lt;/chain>

    &lt;logging-channel-adapter id="logger" log-full-message="true" level="WARN"/>

&lt;/beans:bean></programlisting>
        </para>
        <para>What is the jobMessageLauncher referenced above? It's a Spring Batch Integration
          component to bridge from a Spring Integration Message into the Spring Batch domain:</para>
        <para>
          <programlisting language="xml">    &lt;beans:bean id="jobMessageLauncher" 
           class="org.springframework.batch.integration.launch.JobLaunchingMessageHandler">
        &lt;beans:constructor-arg ref="jobLauncher"/>
    &lt;/beans:bean></programlisting>
        </para>
        <para>Its constructor takes a Spring Batch job launcher as an argument, such as the
          SimpleJobLauncher that we used in the earlier examples.</para>
      </section>
      <section>
        <title>Writing back to Spring Integration</title>
        <para>While using Spring Batch is great for dealing with the file, once we have our
          individual Elements it can be desirable to push them back in to our Spring Integration
          flows. This requires us to create an <interfacename>ItemWriter</interfacename> that our
          job can use to write items as messages to a Spring Integration channel.</para>
        <para>Existing Spring Integration componentry makes this task straightforward. The Spring
          Integration gateway can proxy any interface, wrapping the parameter in a Message and
          delivering to a channel:</para>
        <para>
          <programlisting language="xml">      &lt;gateway service-interface="org.springframework.batch.item.ItemWriter" 
               id="employeeChannelItemWriter" 
               default-request-timeout="100" 
               default-request-channel="processEmployeeCollection" /> </programlisting>
        </para>
        <para>Recall that the <interfacename>ItemWriter</interfacename> interface takes a
            <interfacename>Collection</interfacename> of objects, hence the message that this
          generates will have a <interfacename>Collection</interfacename> as its payload. If we want
          to push the individual objects in to our flow, we need to wire in a splitter:</para>
        <para>
          <programlisting language="xml">    &lt;channel id="processEmployeeCollection"/>
    &lt;splitter input-channel="processEmployeeCollection" output-channel="processEmployee"/>    </programlisting>
        </para>
        <para>That's it! Combining the above 2 techniques allows us to define a core Spring
          Integration flow, with a unified approach to acquiring feeds and a common processing core,
          while still allowing us to delegate file (actually any batch input) to Spring Batch where
          it is advantageous to do so. </para>
      </section>
    </section>
  </section>
</chapter>
